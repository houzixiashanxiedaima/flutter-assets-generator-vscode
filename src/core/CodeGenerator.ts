import * as fs from 'fs';
import * as path from 'path';
import { ResolvedConfig } from '../types/config';
import { AssetConstant } from '../types/asset';

/**
 * Generates Dart code for asset constants
 */
export class CodeGenerator {
  private config: ResolvedConfig;

  constructor(config: ResolvedConfig) {
    this.config = config;
  }

  /**
   * Generate Dart code from asset constants
   * @param constants Array of asset constants
   * @returns Generated Dart code
   */
  generate(constants: AssetConstant[]): string {
    const lines: string[] = [];

    // File header
    lines.push('/// Generated file. Do not edit.');
    lines.push('///');
    lines.push(`/// Generated by Flutter Assets Generator`);
    lines.push(`/// https://github.com/houzixiashanxiedaima/flutter-assets-generator-vscode`);
    lines.push('');

    // Class definition
    lines.push(`class ${this.config.class_name} {`);

    // Private constructor
    lines.push(`  ${this.config.class_name}._();`);
    lines.push('');

    // Generate constants
    const sortedConstants = this.sortConstants(constants);

    for (const constant of sortedConstants) {
      // Add warning comment for conflicts
      if (constant.hasConflict && constant.conflictWith) {
        lines.push(`  /// Warning: Duplicate name with ${constant.conflictWith}`);
      }

      // Add constant
      lines.push(`  static const String ${constant.name} = '${constant.value}';`);
    }

    // Close class
    lines.push('}');
    lines.push('');

    return lines.join('\n');
  }

  /**
   * Sort constants alphabetically by name
   * @param constants Array of asset constants
   * @returns Sorted array
   */
  private sortConstants(constants: AssetConstant[]): AssetConstant[] {
    return [...constants].sort((a, b) => a.name.localeCompare(b.name));
  }

  /**
   * Write generated code to file
   * @param code Generated Dart code
   * @returns Path to generated file
   */
  async writeToFile(code: string): Promise<string> {
    const outputDir = path.join(this.config.projectRoot, 'lib', this.config.output_dir);
    const outputFile = path.join(outputDir, `${this.config.output_filename}.dart`);

    try {
      // Create output directory if it doesn't exist
      await fs.promises.mkdir(outputDir, { recursive: true });

      // Write file
      await fs.promises.writeFile(outputFile, code, 'utf-8');

      return outputFile;
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Failed to write generated file: ${error.message}`);
      }
      throw error;
    }
  }

  /**
   * Generate and write code in one step
   * @param constants Array of asset constants
   * @returns Path to generated file
   */
  async generateAndWrite(constants: AssetConstant[]): Promise<string> {
    const code = this.generate(constants);
    return await this.writeToFile(code);
  }
}
